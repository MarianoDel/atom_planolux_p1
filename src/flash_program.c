/**
  *****************************************************************************
  * @title   FLASH_Program.c
  * @author  CooCox
  * @date    31 Oct 2012
  * @brief   This example provides a description of how to program the STM32F
  *          10x FLASH.
  *          the result of the programming operation is stored in
  *          to the MemoryProgramStatus variable.
  *          Four LEDs are toggled if t
  *          he flash program has been down.
  *          This example has been tested on
  *           KEIL MCBSTM32 board, STM32F103RBT6 device.
  *******************************************************************************
  */
////// The above comment is automatically generated by CoIDE ///////////////////


#include "flash_program.h"
#include "stm32f0xx_flash.h"



/* Externals variables ---------------------------------------------------------*/
#ifdef CONFIGURATION_IN_FLASH
extern unsigned char b1t;
extern unsigned char b1r;
extern unsigned char b2t;
extern unsigned char b2r;
extern unsigned char b3t;
extern unsigned char b3r;
extern unsigned char b4t;
extern unsigned char b4r;

extern parameters_typedef param_struct;
#endif

#ifdef CONFIGURATION_IN_SST
extern parameters_typedef param_struct;
#endif

/* Private typedef -----------------------------------------------------------*/


/* Private define ------------------------------------------------------------*/


extern parameters_typedef param_struct;
extern mem_bkp_typedef memory_backup;
extern filesystem_typedef files;
//extern unsigned int v_bkp [];

/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/

//const int vmem [1024] ;
unsigned int * pmem = (unsigned int *)0x08007000;	//Sector 7 Page 28


/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
unsigned char ReadMem (void)
{
	if (*pmem == 0xffffffff)
		return 1;
	else
		return 0;
}

unsigned char EraseAllMemory_FLASH(void)
{
	unsigned char resp = 0;

	ErasePage(PAGE31,1);
	//reviso si borre

	if (*(unsigned int *) PAGE31 == 0xFFFFFFFF)
		resp++;

	if (resp)
		return PASSED;
	else
		return FAILED;
}

/*
unsigned short Look_Code_In_Memory(unsigned int code_to_look_for)
{
	unsigned short i;

	for (i = 0; i < FLASH_PAGE_SIZE; i++)
	{
		if (*(unsigned int*) (PAGE28_START + i) == code_to_look_for)
			return i;
	}

	return 0xFFFF;
}
*/

unsigned char Write_Code_To_Memory_FLASH(unsigned short position, unsigned int new_code)
{
	//check if possition is good
	if (position > PAGE31_END)
		return FAILED;

	if (position >= PAGE31_START)
	{
		BackupPage(memory_backup.v_bkp, (unsigned int *) PAGE31);
		ErasePage(PAGE31,0);
		if (UpdateNewCode(memory_backup.v_bkp, position - PAGE31_START, new_code) == FAILED)
			return FAILED;

		if (WritePage(memory_backup.v_bkp, PAGE31, 1) == FAILED)
			return FAILED;
	}
	else if (position >= PAGE30_START)
	{
		BackupPage(memory_backup.v_bkp, (unsigned int *) PAGE30);
		ErasePage(PAGE30,0);
		if (UpdateNewCode(memory_backup.v_bkp, position - PAGE30_START, new_code) == FAILED)
			return FAILED;

		if (WritePage(memory_backup.v_bkp, PAGE30, 1) == FAILED)
			return FAILED;
	}
	else if (position >= PAGE29_START)
	{
		BackupPage(memory_backup.v_bkp, (unsigned int *) PAGE29);
		ErasePage(PAGE29,0);
		if (UpdateNewCode(memory_backup.v_bkp, position - PAGE29_START, new_code) == FAILED)
			return FAILED;

		if (WritePage(memory_backup.v_bkp, PAGE29, 1) == FAILED)
			return FAILED;
	}
	else if (position >= PAGE28_START)
	{
		BackupPage(memory_backup.v_bkp, (unsigned int *) PAGE28);
		ErasePage(PAGE28,0);
		if (UpdateNewCode(memory_backup.v_bkp, position, new_code) == FAILED)
			return FAILED;

		if (WritePage(memory_backup.v_bkp, PAGE28, 1) == FAILED)
			return FAILED;
	}

	return PASSED;
}
/**
  * @brief    After Reset, the Flash memory Program/Erase Controller is locked.
  * To unlock it, the FLASH_Unlock function is used. Before programming the
  * desired addresses, an erase operation is performed using the flash erase
  * page feature. The erase procedure starts with the calculation of the number
  * of pages to be used. Then all these pages will be erased one by one by
  * calling FLASH_ErasePage function.
  * Once this operation is finished, the programming operation will be performed by
  * using the FLASH_ProgramWord function. The written data is then checked and the
  * result of the programming operation is stored into the MemoryProgramStatus variable.
  * @param  None
  * @retval None
  */

void BackupPage(unsigned int * p, unsigned int * page_addr)
{
	unsigned short i;

	for (i = 0; i < 255; i++)
	{
		*(p + i) = *(page_addr + i);
	}
}

void ErasePage(uint32_t p_addr, unsigned char with_lock)
{
	FLASH_Unlock();
	FLASH_ErasePage(p_addr);
	if (with_lock)
		FLASH_Lock();
}

unsigned char UpdateNewCode(unsigned int * p, unsigned short posi, unsigned int new_code)
{
	if (posi > 255)
		return FAILED;

	*(p + posi ) = new_code;

	return PASSED;
}

unsigned char WritePage(unsigned int * p, uint32_t p_addr, unsigned char with_lock)
{
	unsigned short i;
	unsigned int * p_verif;

	p_verif = (unsigned int *) p_addr;

	for (i = 0; i < 255; i++)
	{
		FLASH_ProgramWord(p_addr, *(p + i));
		p_addr += 4;
	}

	if (with_lock)
		FLASH_Lock();

	//verifico memoria
	for (i = 0; i < 255; i++)
	{
		if (*(p_verif + i) != *(p + i))
			return FAILED;
	}
	return PASSED;
}


unsigned char WriteConfigurations (void)
{
	parameters_typedef * p_param;

	ErasePage(PAGE31,0);

	//update en memoria
	p_param = &param_struct;

	if (WriteFlash((unsigned int *) p_param, PAGE31, 1, sizeof(parameters_typedef)) == FAILED)
		return FAILED;

	return PASSED;
}

unsigned char WriteFlash(unsigned int * p, uint32_t p_addr, unsigned char with_lock, unsigned char len_in_4)
{
	unsigned short i;
	unsigned int * p_verif;

	p_verif = (unsigned int *) p_addr;

	for (i = 0; i < len_in_4; i++)
	{
		FLASH_ProgramWord(p_addr, *(p + i));
		p_addr += 4;
	}

	if (with_lock)
		FLASH_Lock();

	//verifico memoria
	for (i = 0; i < len_in_4; i++)
	{
		if (*(p_verif + i) != *(p + i))
			return FAILED;
	}
	return PASSED;
}
